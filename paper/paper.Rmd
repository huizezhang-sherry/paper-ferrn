---
title: Title here

# to produce blinded version set to 1
blinded: 0

authors: 
- name: Author 1
  thanks: The authors gratefully acknowledge ...
  affiliation: Department of YYY, University of XXX
  
- name: Author 2
  affiliation: Department of ZZZ, University of WWW

keywords:
- 3 to 6 keywords
- that do not appear in the title

abstract: |
  1. check consistency of using PP for projection pursuit and PPI for projection pursuit index 

bibliography: biblio.bib
output: rticles::asa_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)

library(tidyverse)
library(ferrn)
library(patchwork)
library(ggrepel)

load(here::here("data/temp.rda"))
load(here::here("data/data_mult.rda"))
load(here::here("data/holes_1d_geo.rda"))
load(here::here("data/holes_2d_geo.rda"))
load(here::here("data/holes_2d_better.rda"))
load(here::here("data/holes_2d_better_max_tries.rda"))
load(here::here("data/holes_2d_better_random.rda"))
load(here::here("data/holes_2d_geo_polish.rda"))
load(here::here("data/holes_2d_better_polish.rda"))
load(here::here("data/holes_2d_better_max_tries_polish.rda"))
load(here::here("data/holes_2d_better_random_polish.rda"))
load(here::here("data/interrupt_yes.rda"))
load(here::here("data/interrupt_no.rda"))

```


# Introduction

## Tour

Tour provides a way to explore multivariate data interactively via an established tour path. A tour path is formed by interpolating between randomly generated plane. Different types of tours are available depends on the purpose of the exploration i.e. a grand tour is suitable for randomly exploring the data from different angles; a guided tour detects a particular structure in the data. a manual tour allows user to manually control the projection [@cook1997manual]. 

## Guided tour

Guided tour is usually used in conjunction projection pursuit, a method coined by @friedman1974projection to detect "interesting" low-diemsion projection of multivariate data. A projection pursuit requires the definition of a projection pursuit index function and an optimisation routine. The projection pursuit index measures the "interestingness" of data defined as its departure from normality. Numerous indices have been proposed in the literature, including lengendre index [@friedman1974projection], hermite index [@hall1989polynomial], natural hermite index [@cook1993projection], chi-square index [@posse1995projection], LDA index [@lee2005projection] and PDA index [@lee2010projection]. An optimisation routine is required to find the projection basis (thus projection) that maximises the projection pursuit index. The discussion of existing optimisation procedure will be discussed in the next section.

Guided tour creates visualisation for the projections found by projection pursuit by constructing a tour path. An illustration modified from [@buja2005computational] entails the geodesic interpolation bewteen the plane generated by projection pursuit.

```{r}
knitr::include_graphics(path = here::here("figures/tour_path_new.png"))
```


## Optimisation methods in projection pursuit literature

As @friedman1974projection said "..., the technique use for maximizing the (one- and two-dimensional) projection index strongly influences both the statistical and the com- putational aspects of the procedure." The quality of the optimisation procedure largely affect the tour view and thus, the interesting projection one could possibly observe. An ideal optimisation procedure needs to have following characteristics: 

- *Being able to handle non-differentiable index function*: the index function could be noisy and non-differentible

- *Being able to optimise with constraints*: the projection matrix is restricted to an orthornormal matrix. 

- *Being able to reveal both local and global maximum*: Although the primary interest is to find the global maximum, distinct local structures are also of our interest. 

Below present three existing methods in tour. 

@posse1995projection presented a random search algorithm that samples new basis in the neighbourhood of the current basis. The neighbourhood is defined via the radius of the p-dimenionsal sphere, $c$. The new basis is taken as the target basis if it has higher index value, or the sampling continues. If no basis is found to have higher index value after a certain humber of tries $n$, the radius $c$ is halved. The algorithm stops when the maximum numbere of iteration is attained or the radius $c$ is less than a pre-determined number. [Pursuit package uses this method and it works greate! But I don't think we implement this - although don't think it is too hard to do it]. 

@cook1995grand explained the use of a gradient ascent optimisation with the assumption that the index function is continuous and differentiable. Since some indices could be non-differentiable, the computation of derivative is replaced by a psudo-derivative of evaluating five randomly generated directions in a tiny nearby neighbourhood. Taking a step on the straight derivative direction has been modified to maximise the projection pursuit index along the geodesic direction. 

Simulated annealing [@bertsimas1993simulated, @kirkpatrick1983optimization] is a non-derivative procedure based on a non-increasing cooling scheme $T(i)$. Given an initial $T_0$, the temperature at iteration $i$ is defined as $T(i) = \frac{T_0}{log(i + 1)}$. The simulated annealing algorithm works as follows. Given a neighbourhood parameter $\alpha$ and a randomly generated orthonormal basis $B$, a candidate basis is constructed as $B_j = (1- \alpha)B_i + \alpha B$ where $B_i$ is the current basis. If the index value of the candidate basis is larger than the one of the current basis, the candidate basis becomes the target basis. If it is smaller, the candidate is accepted with probability $A = \min \left(\exp(-\frac{I(B_j) - I(B_i)}{T(i)}), 1 \right)$ where $I(.)$ is the index function. 


<!-- Because of the fact that projection pursuit index can be non-differentiable and that the projection basis is constrained to be orthonormal, the optimisation need to be a derivative-free, constrained procedure. Also, local maxima is equally interested as global maxima since it reveals distinct local structure in the data. -->

## problems and difficulties in PP optimisation

Below listed several issues in projection pursuit optimisation. Some are general optimisation problems, while others are more specific for PP optimisation. 

- *Finding global maximum*: Although finding local maximum is relatively easy with developed algorithms, it is generally hard to guarantee global maximum in a problem where the objective function is complex or the number of decision variables is large. Also, there are discussions on how to avoid getting trapped in a local optimal in the literature.

- *optimising non-smooth function*: When the objective function is non-differentiable, derivative information can not be obtained, which means traditional gradient- or Hessian- based methods are not feasible. Stochastic optimisation method could be an alternative to solve these problems.

- *computation speed*: The optimisation procedure needs to be fast to compute since tours produces real-time animation of the projected data.

- *consistency result in stochastic optimisation*: In stochastic algorithm, researchers usually set a seed to ensure the algorithm producing the same result for every run. This practice supports reproducibility, while less efforts has been made to guarantee different seeds will provide the same result. 

- *high-dimensional decision variable*: In projection pursuit, the decision variable includes all the entries in the projection matrix, which is high-dimensional. Researcher would be better off if they can understand the relative position of different projection matrix in the high-dimensional space. 

- *role of interpolation in PP optimisation*: An optimisation procedure usually involves iteratively finding projection bases that maximises the index function, while tour requires geodesic interpolation between these bases to produce a continuous view for the users. It would be interesting to see if the interpolated bases could, in reverse, help the optimisation reach faster convergence.

<!-- the interpolation can be seen as giving information on the direction of the derivative. -->


<!-- - is `search_geodesic` widely known in the research community - doesn't seem to find paper introducing this except (Cook, 1995). Any tools available to  better understand its searching process? -->

*Think about how does your pacakge help people to understand optimisation*
 
 - diagnostic on stochastic optim
 - vis the prograssion of multi-parameter decision variable 
 - understanding learning rate - neightbourhood parameter
 - understand where the local & global maximum is found - trace plot - see if noisy function



# Recording the guided tour

## Tour components

Guided tour, along with other types of tour, has been implemented in the *tourr* package in R, available on the Comprehensive R Archive Network at [https://cran.r-project.org/web/packages/tourr/](https://cran.r-project.org/web/packages/tourr/) [@wickham2011tourrpackage]. A tour includes two major components: a *generator* that generating the projection basis according to projection pursuit and an *interpolator* that performing geodesic interpolation between the projection basis. 

The psudo-code below illustrates the implementation of guided tour in the tourr package. Given an projection pursuit index function and a randomly generated projection basis (current basis), the optimisation procedure produces a target basis inside `generator()`  Both the current basis and the target basis will be supplied to `tour_path()` to prepare information needed for constructing a geodesic path. This information is then used to compute a series of interpolating bases inside the `tour()` function. All the basis will be sent to create animation for visualising the tour in the `animate()` function.  


```{r eval = FALSE, echo = TRUE}
animation <- function(){
  
  # compute projection basis 
  tour <- function(){
    
    # construct bases on the tour path
    new_geodesic_path <- function(){
      tour_path <- function(){
        
        # GENERATOR: generate projection basis via projection pursuit
        guided_tour <- function(){
          generator <- function(){
            
            # define projection pursuit index
            # generate the target basis from the current basis via optimisation
          }
        }
        
        # prepare geodesic information needed for interpolating along the tour path
      }
    }
    
    # INTERPOLATOR: interpolate between the current and target basis 
    function(){
      # generate interpolating bases on the geodesic path
    }
  }
  
  # animate according to different display methods
}
```


## Data Structure

In the current implementation of the `tourr` package, while the target basis generated by the projection pursuit can be accessed later via `save_history()`, interpolating bases and those randonly nearby bases generated in the optimisation are not stored. This creates difficulties for fully understand the behaviour of the optimisation and interpolation of tour in complex scenario **[needa rephrase this part].** 

Two set of simulated data are used in the demonstration of the visualiation and diagnostics of the tour optimisation. A small dataset consists of 1000 randomly simulated observations of five variables (`x1`, `x2`, `x8`, `x9`, `x10`). `x2` is the informative variable simulated from two bi-modal normal distribution centered at -3 and 3 with variance being 1 and the other four are simulated from `N(0, 1)`. The data has been scaled to ensure `x2` has variance of 1. 

A larger dataset contains more informative variables (`x3` to `x7`) of different types. `x3` takes 500 positive one and 500 negative one. The distribution of all the variables except `x3` is plotted below. *[should I introduce the dist for each var?]*

```{r}
origin_dt_bi <- data_mult %>% 
  dplyr::select(-x3) %>% 
  gather(names, values) %>%
  mutate(names = as_factor(names))
  
origin_dt_bi %>%
  ggplot(aes(x = values)) +
  geom_histogram(binwidth = 0.3) +
  geom_density(aes(y = 0.3 * ..count..)) +
  facet_wrap(vars(names), ncol = 3)
```

Once the dataset is sent to the tourr package, all the information generated will be stored in a global structure. The global structure consists of six columnes: `basis`, `index_val`, `tries`, `info`, `loop`, `id` and captured all the basis generated during whole tour process. The example below presents the global object of a 1D projection of the small dataset with geodesic seraching method. 

```{r eval = FALSE}
set.seed(123456)
holes_1d_geo <- animate_dist(data, tour_path = guided_tour(holes(), d = 1,
                                           search_f =  search_geodesic),
                  rescale = FALSE, verbose = TRUE)

#save(temp, file = here::here("vignettes", "data", "temp.rda"))
```

```{r echo = TRUE}
holes_1d_geo %>% head(5)
```

`tries` has an increment of one once the generator is called (equivalently a new target basis is generated); `info` records the stage the basis is in. This would include the `interpolation` stage and the detailed stage in the optimisation i.e. `direction_search`, `best_direction_search`, `line_search`and `best_line_search` for geodesic searching (`search_geodesic`); `random_search` and `new_basis` for simulating annealing (`search_better`). `loop` is the counter used for the optimisation procedure and thus will be `NA` for interpolation steps. `id` creates a sequential order of the basis. This information will be stored and printed when the optimisation ends and can be turned off via `print = FALSE`. Additional messages during the optimisation can be displayed via `verbose = TRUE`. Another examples is a 2D projection of the larger dataset with two informative variable (`x2` and `x7`) using search_better method. Notice in this example, the dimension of the bases becomes 6 by 2.


```{r echo = TRUE}
holes_2d_better %>% head(5) 
```


# Visual methods

## add something about general vis 



The creation of the global object facilitates the diagnostics of the optimisation in the projection pursuit guided tourr. Different diagnostic plots could be made to understand the optimisation **[pretty cheesy here]**

*The examples and results below still need to be modified as the development / modification of both ferrn and tourr package*.


## index vs time plots

The tracing plot is useful to explore the index value. Given a global object created, `explore_trace_all()` plots the index value of all the bases. 

```{r echo = TRUE}
holes_2d_geo %>% explore_trace_all(magnify = TRUE)
holes_2d_geo %>% explore_trace_interp()
```


## target basis vs interpolation steps, index vs time

## low-d representation, PCA

```{r echo = TRUE}
holes_1d_geo %>% explore_proj_pca()
```



# Animating plots

```{r echo = TRUE, eval = FALSE}
holes_1d_geo %>% explore_proj_pca(animate = TRUE)
```


# Finding errors and developing improvements

The visualisation methods introduced above allow us to assess the performance of each optimisation routine and thus provide improvments. 


## Interrupt

The left panel of Figure \@ref(fig:interruption) presents the trace plot of the interpolated basis using `search_better` to optimise the holes index (2D projection using the larger dataset). Tour interpolates from the current basis to the target basis, which has been found to have a higher index value by projection pursuit. The target basis will then be sent to the projection pursuit as the current basis to find the next target basis. We can observe from the plot that there are basis with even higher index value on the interpolation path. These bases could be used to search for new basis in the next round. Therefore, an interruption is constructed to only take interpolated basis up to the point where the index value stops increasing and the last basis is taken as the current basis for the next round of search. After implementing the interruption, the tracing plot with the same configuration is shown on the right panel. Rather than interpolate to the target basis, the interruption interrupt the process after id = 60 and proceeds the next round of search from the interpolated basis. Taking advantage of the interpolated basis results in a higher index value in the end with fewer steps.


```{r interruption, fig.cap = "\\label{interruption} Trace plots of the interpolated basis with and without the interruption. The interruption stops the interpolation when the index value starts to decrease, see the difference at id being around 60. The implementation of the interuption finds an ending basis with higher index value using fewer steps. "}
p1_anno <- interrupt_no %>% filter(info == "interpolation") %>% mutate(id = row_number()) %>% filter(id %in% c(44, 60, 62)) %>% 
  mutate(anno = c("current basis", "interpolated basis", "target basis"))

p1 <- interrupt_no %>% mutate(id = row_number() - 1) %>% explore_trace_interp() + ggtitle("without interruption") + 
  geom_point(data = p1_anno) + 
  geom_label_repel(data = p1_anno, aes(label = anno), box.padding = 0.5) + ylim(0.8, 0.9) + xlim(0, 80)
  
p2 <- interrupt_yes %>% explore_trace_interp() + ggtitle("with interruption") + ylim(0.8, 0.9) + xlim(0, 80)

p1 | p2
```



Further the case when the index function is not smooth, the interpolation may not attain -> modification


## Polish

In principle, all the optimisation routines should present the same output on the same problem. In Figure \@ref(fig:trace-compare), red dots shows the trace of the interpolated basis using `search_geodesic` and `search_better` (with max.tries = 100), respectively, on the 2D projection problem. We can observe that they attain slightly different ending index value, which is not ideal. This motivates the creation of a polishing search that polishes the ending basis and achieves unity on different methods. 

```{r}
p1 <- bind_rows(holes_2d_geo, holes_2d_geo_polish) %>% 
  explore_trace_interp(point = TRUE) + ggtitle("search_geodesic")

p2 <- bind_rows(holes_2d_better_max_tries, holes_2d_better_max_tries_polish) %>% 
  explore_trace_interp(point = TRUE) + ggtitle("search_better")


(p1 | p2) &
  theme(legend.position = "none") 
```


`search_polish` takes the ending basis of a given search as the starting basis and uses a brutal-force approach to sample a larger number of basis (`n_sample`) in the neightbourhood, controlled by `polish_alpha`. Among the `n_sample` basis, the one with the largest index value becomes the candidate. If its index value is larger than that of the starting basis, it becomes the center of the searching neightbourhood in the next round. If no basis is found to have larger index value than the starting basis, the searching neighbourhood will shrink and the search continues. The polishing search ends when one of the four stopping criteria is satisfied:

1) the two basis can't be too close 
2) the improvement can't be too small 
3) the searching neighbourhood can't be too small
4) the number of iteration can't exceed the max.tries

The usage of search_polish is as follows. After the first tour, the final basis from the interpolation is extracted and supplied into a new tour with the `start` argument and `search_polish` as the searching function in the guided_tour. All the other arguments should remain the same. 

```{r eval = FALSE, echo = TRUE}
set.seed(123456)
holes_2d_geo <- animate_xy(data_mult[,c(1,2, 7:10)],tour_path = 
                             guided_tour(holes(), d = 2, 
                                         search_f = tourr:::search_geodesic),
                           rescale = FALSE, verbose = TRUE)

last_basis <- holes_2d_geo %>% filter(info == "interpolation") %>% 
  tail(1) %>% pull(basis) %>% .[[1]]

set.seed(123456)
holes_2d_geo_polish <- animate_xy(data_mult[,c(1,2, 7:10)], tour_path = 
                                    guided_tour(holes(), d = 2, 
                                                search_f = tourr:::search_polish),
                                  rescale = FALSE, verbose = TRUE, 
                                  start = last_basis)
```

The following example conducted a 2D projection on the larger dataset using search better with different configurations. `max.tries` is a hyperparameter that controls the maximum number of try without improvement and its default value is 25. As shown in Figure \@ref(fig:trace-compare), after polishing, both trials attain the same index value. However, a small `max.tries` of 25 is not sufficient for the algorithm to find the true maximum. This is because 25 tries is not sufficient for the 2D searching space.  

```{r trace-compare, fig.cap="Breakdown of index value when using different max.tries in search better in conjunction with search polish. Both attain the same final index value after the polishing while using a max.tries 25 is not sufficient to find the ture maximum."}

p1 <- bind_rows(holes_2d_better, holes_2d_better_polish) %>% 
  explore_trace_interp(point = TRUE) + ggtitle("max.tries = 25")

p2 <- bind_rows(holes_2d_better_max_tries, holes_2d_better_max_tries_polish) %>% 
  explore_trace_interp(point = TRUE) + ggtitle("max.tries = 500")

(p1 | p2) &
  theme(legend.position = "none") 
```


## posse?

search_better annd search_geodesic methods are not doing good on 2d projection -> see the simple case above: abs best is 0.96 while they only get to 0.88-ish. Would be worse for higher dimension. thus search_posse. get 0.95 and then polish to 0.96 :)



# Vis package



